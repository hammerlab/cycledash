{% extends "layouts/layout.html" %}
{%- from 'macros/nav.html' import nav -%}

{% block bootstrap %}{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/examine.css') }}">

<script src="{{ url_for('static', filename='js/d3.bar-chart.js') }}"></script>
<script src="{{ url_for('static', filename='js/idiogrammatik.js') }}"></script>
<script src="{{ url_for('static', filename='js/vcf.js') }}"></script>
<script src="{{ url_for('static', filename='js/vcf.tools.js') }}"></script>

<script src="http://fb.me/react-0.11.1.js"></script>
<script src="http://fb.me/JSXTransformer-0.11.1.js"></script>

<script type="text/javascript" src="//use.typekit.net/vml3kel.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>
{% endblock %}


{% block body %}
<script>
 var VCF_PATH = "{{ run['vcfPath'] }}";
 var TRUTH_VCF_PATH = "{{ run['truthVcfPath'] }}";
</script>

{% raw %}
<script type="text/jsx">
/** @jsx React.DOM */

var ExaminePage = React.createClass({
   getInitialState: function() {
     return {charts: [],
             filters: {},
             position: {start: 0,
                       end: null, // 'null' for end means "the end."
                       chromosome: "all"}};
   },
   getDefaultProps: function() {
     return {records: [],
             truthRecords: [],
             karyogram: initializeKaryogram(),
             chromosomes: [],
             attrs: []};
   },
   componentDidMount: function() {
     d3.xhr('/vcf' + this.props.vcfPath, function(err, response) {
       var records = vcf()
                        .parseChrom(function(chr){ return 'chr' + chr; })
                        .data(response.responseText)
                        .data();
       var attrs = _.keys(records[0].INFO);
       var chromosomes = chromosomesFrom(records);

       d3.xhr('/vcf' + this.props.truthVcfPath, function(err, response) {
         var truthRecords = vcf()
                              .parseChrom(function(chr){ return 'chr' + chr; })
                              .data(response.responseText)
                              .data();

         this.setProps({records: records, chromosomes: chromosomes,
                        attrs: attrs, truthRecords: truthRecords});
       }.bind(this))
     }.bind(this));
   },
   handleRangeChange: function(start, end) {
     this.setState({position: {start: start, end: end, chromosome: "all"}});
   },
   handleRelativeRangeChange: function(start, end) {
     this.setState({position: {start: start, end: end,
                               chromosome: this.state.position.chromosome}});
   },
   handleFilterUpdate: function(filters) {
     this.setState({filters: filters});
   },
   handleChartChange: function(chart) {
     this.setState({charts: this.togglePresence(this.state.charts, chart)});
   },
   handleChromosomeChange: function(chromosome) {
     var start, end;
     if (chromosome === 'all') {
       start = 0;
       end = null;
     } else {
       var chr = chromosome;
       start = this.props.karyogram.positionFromRelative(chr, 0).absoluteBp;
       end = this.props.karyogram.positionFromRelative(chr, null).absoluteBp;
     }
     this.setState({position: {start: start, end: end, chromosome: chromosome}});
   },
   togglePresence: function(list, el) {
     var idx;
     if ((idx = list.indexOf(el)) > -1) {
       list.splice(idx, 1);
     } else {
       list.push(el);
     }
     return list;
   },
   recordWithinRange: function(record) {
     var start = this.state.position['start'],
         end = this.state.position['end'];

     try {
       var pos = this.props.karyogram.positionFromRelative(record.CHROM, record.POS).absoluteBp;
     } catch (e) {
       /* console.warn('Ignoring: ', record.__KEY__); */
       return false;
     }
     return pos >= start && (!end || pos <= end);
   },
   recordPassesInfoFilters: function(record) {
     return _.reduce(this.state.filters, function(passes, filterVal, filterName) {
       if (!passes) return false; // If one fails, they all fail.
       if (filterVal.length === 0) return true;

       if (_.contains(['<', '>'], filterVal[0])) { // then do a numeric test
         var val = Number(record.INFO[filterName]);
         if (filterVal[0] === '>') {
           return val > Number(filterVal.slice(1));
         } else {
           return val < Number(filterVal.slice(1));
         }
       } else { // treat it like a regexp, then...
         var re = new RegExp(filterVal);
         if (filterName === 'refAlt') {
           return re.test(record.REF + "/" + record.ALT);
         } else {
           return re.test(record.INFO[filterName]);
         }
       }
     }, true);
   },
   filterRecords: function(records, skipFilters) {
     return records.filter(function(record) {
       return this.recordWithinRange(record) && (skipFilters || this.recordPassesInfoFilters(record));
     }.bind(this));
   },
   render: function() {
     var filteredRecords = this.filterRecords(this.props.records);
     var filteredTruthRecords = this.filterRecords(this.props.truthRecords, true);
     return (
       <div className="examinePage">
         <h1>Examining: <small>{VCF_PATH}</small></h1>
         <TrueFalsePosNeg records={filteredRecords} truthRecords={filteredTruthRecords} />
         <AttributeCharts records={filteredRecords}
                          charts={this.state.charts} />
         <Karyogram start={this.state.position['start']}
                    end={this.state.position['end']}
                    karyogram={this.props.karyogram}
                    handleRangeChange={this.handleRangeChange} />
         <VCFTable records={filteredRecords} position={this.state.position}
                   attrs={this.props.attrs}
                   handleChartChange={this.handleChartChange}
                   handleFilterUpdate={this.handleFilterUpdate}
                   handleChromosomeChange={this.handleChromosomeChange}
                   handleRelativeRangeChange={this.handleRelativeRangeChange}
                   chromosomes={this.props.chromosomes}
                   karyogram={this.props.karyogram} />
       </div>
     );
   }
});

var AttributeCharts = React.createClass({
  render: function() {
    var charts = this.props.charts.map(function(chart) {
      return <AttributeChart chart={chart} key={chart}
                             records={this.props.records} />;
    }.bind(this));
    return (
      <div className="attributeCharts">
        {charts}
      </div>
    );
  }
});

var AttributeChart = React.createClass({
   binPos: function(bins, val) {
     // Given a sorted array of numbers, bins, of lower bin bounds, returns the
     // position index in those bins that val should go. Undefined behavior if
     // the val is outside the bins.
     //
     // e.g. bins = [5, 10, 15, 20], val = 7   =>   0
     // e.g. bins = [0, 10, 20, 30], val = 21  =>   2
     // e.g. bins = [0, 10, 20, 30], val = 31  =>   3
     return _.reduce(bins, function(pos, binMin) {
       if (binMin >= val) return pos;
       else return pos + 1;
     }, 0);
   },
   processRecordsForHistogram: function(records) {
     var TOTAL_BINS = 10,
         attr = this.props.chart,
         binRange = d3.extent(records.map(function(record) { return record.INFO[attr]; })),
         binGap = (binRange[1] - binRange[0]) / TOTAL_BINS,
         bins = _.range(TOTAL_BINS + 1).map(function(idx) {
           return binRange[0] + (binGap * idx);
         }),
         binned = bins.map(function(bin){ return {bin: bin, count: 0}; });

     _.each(records, function(record) {
       var attrVal = record.INFO[attr],
           pos = this.binPos(bins, attrVal);
       binned[pos].count += 1;
     }.bind(this));

     return binned;
   },
   componentDidMount: function() {
     var datum = this.processRecordsForHistogram(this.props.records),
         barChart = d3.chart.bars()
           .xTickFormatter(d3.format('.1f'))
           .width(450).height(250).margin({top:0, bottom:30, right:0, left: 50})
           .yLabel('Count')
           .intraGroupPadding(0.033)
           .groupBy('bin')
           .barValue('count');

     d3.select(this.refs.chartHolder.getDOMNode())
         .datum(datum)
         .call(barChart);
   },
   componentWillReceiveProps: function(nextprops) {
     d3.select(this.refs.chartHolder.getDOMNode()).select('svg')
       .remove();

     var datum = this.processRecordsForHistogram(nextprops.records),
         barChart = d3.chart.bars()
           .xTickFormatter(d3.format('.1f'))
           .width(450).height(250).margin({top:0, bottom:30, right:0, left: 50})
           .yLabel('Count')
           .intraGroupPadding(0.033)
           .groupBy('bin')
           .barValue('count');

     d3.select(this.refs.chartHolder.getDOMNode())
         .datum(datum)
         .call(barChart);
   },
   render: function() {
     return (
       <div className="attrChart">
         <h4>{this.props.chart}</h4>
         <div ref="chartHolder"></div>
       </div>
     );
   }
});

var Karyogram = React.createClass({
   componentDidMount: function() {
     idiogrammatik.load(function(err, data) {
       if (err) console.error(err);
       var firstPos = null,
           selection = {},
           shifted = false;

       this.props.karyogram
        .on('dragstart', function(position, kgram) {
          if (!position.chromosome || !shifted) return;
          firstPos = position;
         })
        .on('drag', function(position, kgram) {
          if (!position.chromosome || !shifted) return;
          kgram.highlights().remove();
          selection = kgram.highlight(firstPos, position);
         })
        .on('dragend', function(position, kgram) {
          if (!position.chromosome || !shifted) return;
          kgram.highlights().remove();
          var start, end;
          if (firstPos.absoluteBp > position.absoluteBp) {
            start = position.absoluteBp;
            end = firstPos.absoluteBp;
          } else {
            start = firstPos.absoluteBp;
            end = position.absoluteBp;
          }
          this.props.handleRangeChange(start, end);
          selection = kgram.highlight(firstPos, position);
         }.bind(this));

       window.onkeydown = function(e) {
         if (e.shiftKey) {
           document.getElementsByTagName("body")[0].style.cursor = "text";
           shifted = true;
           try {
             this.props.karyogram.zoomBehavior().x(null);
           } catch(err) {}
         }
       }.bind(this);
       window.onkeyup = function(e) {
         document.getElementsByTagName("body")[0].style.cursor = "default";
         if (shifted && !e.shiftKey) {
           shifted = false;
           this.props.karyogram.zoomBehavior().x(this.props.karyogram.scale());
         }
       }.bind(this);

       d3.select(this.getDOMNode())
           .datum(data)
           .call(this.props.karyogram);
     }.bind(this));
   },
   render: function() {
     this.props.karyogram.highlights().remove();
     this.props.karyogram.highlight(this.props.start, this.props.end);
     return <div className="karyogram"></div>;
   }
});

var VCFTable = React.createClass({
   render: function() {
     return (
       <table>
         <VCFTableHeader attrs={this.props.attrs}
                         handleChartChange={this.props.handleChartChange} />
         <VCFTableFilter chromosomes={this.props.chromosomes}
                         records={this.props.records}
                         handleFilterUpdate={this.props.handleFilterUpdate}
                         handleChromosomeChange={this.props.handleChromosomeChange}
                         chromosome={this.props.position.chromosome}
                         position={this.props.position}
                         handleRelativeRangeChange={this.props.handleRelativeRangeChange}
                         attrs={this.props.attrs}
                         karyogram={this.props.karyogram}/>
         <VCFTableBody records={this.props.records} attrs={this.props.attrs} />
       </table>
     );
   }
});

var VCFTableHeader = React.createClass({
   handleChartToggle: function(e) {
     this.props.handleChartChange(e.target.textContent);
   },
   render: function() {
     var attrs = this.props.attrs.map(function(attr) {
       return <th className="attr" key={attr} onClick={this.handleChartToggle}>{attr}</th>;
     }.bind(this));
     return (
       <thead>
         <tr>
           <th>Chromosome</th>
           <th>Position</th>
           <th>REF / ALT</th>
           {attrs}
         </tr>
       </thead>
     );
   }
});

var VCFTableFilter = React.createClass({
   handleChromosomeChange: function(e) {
     var chromosome = this.refs.chromosome.getDOMNode().value;
     this.props.handleChromosomeChange(chromosome);
   },
   handleRelativeRangeChange: function(e) {
     var start = this.refs.startPos.getDOMNode().value,
         end = this.refs.endPos.getDOMNode().value,
         chromosome = this.props.position.chromosome;
     if (start.length === 0 || Number(start) === NaN || Number(end) === NaN) {
       return;
     } else {
       start = Number(start);
       end.length > 0 && Number(end) != NaN ? end = Number(end) : end = null;
     }

     if (chromosome != 'all') {
       var position = this.props.karyogram.positionFromRelative(chromosome, start);
       start = position.absoluteBp;
       if (end != null) {
         end = this.props.karyogram.positionFromRelative(chromosome, end).absoluteBp;
       } else {
         end = position.chromosome.end;
       }
     }
     this.props.handleRelativeRangeChange(start, end);
   },
   handleFilterUpdate: function(e) {
     var filters = Array.prototype.slice.call(document.querySelectorAll('input.infoFilter'));
     filters = _.object(filters.map(function(f) {
       return [f.name, f.value];
     }));
     this.props.handleFilterUpdate(filters);
   },
   render: function() {
     var start, end,
         kgram = this.props.karyogram;
     if (this.props.position.chromosome != 'all') {
       start = kgram.positionFromAbsoluteBp(this.props.position.start).relativeBp;
       end = kgram.positionFromAbsoluteBp(this.props.position.end).relativeBp;
     } else {
       start = this.props.position.start;
       end = this.props.position.end;
     }

     var chromosomeOptions = this.props.chromosomes.map(function(chromosome) {
       return (
         <option name="chromosome" key={chromosome} value={chromosome}>{chromosome}</option>
       );
     }.bind(this));
     var attrs = this.props.attrs.map(function(attr) {
       return (
         <th key={attr}>
           <input name={attr} className="infoFilter" type="text"
                  onChange={this.handleFilterUpdate}>
           </input>
         </th>
       );
     }.bind(this));
     return (
       <thead>
         <tr>
           <th>
             <select onChange={this.handleChromosomeChange}
                     ref="chromosome" value={this.props.chromosome}>
               <option name="chromosome" key="all" value="all">&lt;all&gt;</option>
               {chromosomeOptions}
             </select>
           </th>
           <th id="position">
             <input name="start" type="text" placeholder="start"
                    ref="startPos" value={start} onChange={this.handleRelativeRangeChange}>
             </input>
             <input name="end" type="text" placeholder="end"
                    ref="endPos" value={end} onChange={this.handleRelativeRangeChange}>
             {this.props.position.end}
             </input>
           </th>
           <th>
             <input name="refAlt" className="infoFilter" type="text"
                    onChange={this.handleFilterUpdate}></input>
           </th>
           {attrs}
         </tr>
       </thead>
     );
   }
});

var VCFTableBody = React.createClass({
   render: function() {
     var rows = this.props.records.map(function(record, idx) {
       return <VCFRecord record={record} key={record.__KEY__} even={idx % 2 == 0}
                         attrs={this.props.attrs}/>;
     }.bind(this));
     return (
       <tbody>
         {rows}
       </tbody>
     );
   }
});

var VCFRecord = React.createClass({
   render: function() {
     var attrs = this.props.attrs.map(function(attr) {
       var val = this.props.record.INFO[attr];
       return <td key={attr}>{String(val)}</td>;
     }.bind(this));
     return (
       <tr className={this.props.even ? "even" : "odd"}>
         <td>{this.props.record.CHROM}</td>
         <td className="pos">{this.props.record.POS}</td>
         <td>{this.props.record.REF}/{this.props.record.ALT}</td>
         {attrs}
       </tr>
     );
   }
});

var TrueFalsePosNeg = React.createClass({
   render: function() {
     var truePositives = vcf.tools.truePositives(this.props.truthRecords, this.props.records).length,
         falsePositives = vcf.tools.falsePositives(this.props.truthRecords, this.props.records).length,
         falseNegatives = vcf.tools.falseNegatives(this.props.truthRecords, this.props.records).length;

     var precision = truePositives / (truePositives + falsePositives),
         recall = truePositives / this.props.truthRecords.length,
         f1score = 2 * (precision * recall) / (precision + recall);

     var fmt = d3.format(','),
         dfmt = d3.format('.4f');
     return (
       <table className="trueFalsePosNeg">
         <thead>
           <tr>
             <th></th>
             <th>True</th>
             <th>False</th>
           </tr>
         </thead>
         <tbody>
           <tr id="positive">
             <td>Postive</td>
             <td>{fmt(truePositives)}</td>
             <td>{fmt(falsePositives)}</td>
           </tr>
           <tr id="negative">
             <td>Negative</td>
             <td className="na">N/A</td>
             <td>{fmt(falseNegatives)}</td>
           </tr>
           <tr>
             <td>Precision</td>
             <td>Recall</td>
             <td>f1score</td>
           </tr>
           <tr>
             <td>{dfmt(precision) || "N/A"}</td>
             <td>{dfmt(recall) || "N/A"}</td>
             <td>{dfmt(f1score) || "N/A"}</td>
           </tr>
         </tbody>
       </table>
     );
   }
});


function main() {
   var examinePage = React.renderComponent(<ExaminePage vcfPath={VCF_PATH}
                                                        truthVcfPath={TRUTH_VCF_PATH} />,
                                           document.getElementsByTagName('body')[0]);
}


function chromosomesFrom(records) {
  return _.reduce(records, function(acc, val, key) {
     var chromosome = val.CHROM;
     if (acc.mem[chromosome] === undefined) {
       acc.mem[chromosome] = true;
       acc.chromosomes.push(chromosome);
     }
     return acc;
   }, {chromosomes: [], mem: {}}).chromosomes;
}

function initializeKaryogram() {
  idiogrammatik.__cytoband_url__ = '/static/js/cytoband.tsv'
  var karyogram = idiogrammatik()
        .width(1400)
        .highlightHeight(59);

  return karyogram;
}

main();


</script>
{% endraw %}
{% endblock%}
